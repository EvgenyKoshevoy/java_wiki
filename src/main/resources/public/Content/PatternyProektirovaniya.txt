	Паттерны проектирования
	
Порождающие:
	- Singleton (Одиночка) - ограничивает созданиеодного экземпляра класса. Обеспечивает доступ к его единственному объекту.
	- Factory (Фабрика) - используется, когда у нас есть суперкласс с несколькими подклассами и на основе ввода, нам нужно вернуть один из подкласса.
	- Abstract Factory (Абстрактная фабрика) - используем супер фабрику для создания фабрики, затем используем созданную фабрику для создания объектов.
	- Builder (Строитель) - используется для создания сложного объекта с использованием простых объектов. Постепенно он создает больший объект от малого и простого объекта.
	- Prorotype (Прототип) - помогает создать дублированный объект с лучшей производительностью, вместо нового создается возвращаемый клон существующего объекта.
	
Структурные:
	- Adapter (Адаптер) - это конвертер между двумя несовместимыми объектами. Используя паттерн адаптера, мы можем объединить два несовместимых интерфейса.
	- Composite (Компоновщик) - использует один класс для представления древовидной структуры.
	- Proxy (Заместитель) - представляет функциональность другого класса.
	- Flyweight (Легковес) - вместо создания большого количества похожих объектов, объекты используются повторно.
	- Facade (Фасад) - обеспечивает простой интерфейс для клиента, и клиент использует интерфейс для взаимодействия с системой.
	- Brige (Мост) - делает конкретные классы независимыми от классов реализации интерфейса.
	- Decorator (Декоратор) - добавляет новые функциональные возможности существующего объекта без привязки его структуры.
	
Поведенческие:
	- Template Method (Шаблонный метод) - определяющий основу алгоритма и позволяющий наследникам переопределять некоторые шаги алгоритма, не изменяя его структуру в целом.
	- Mediator (Посредник) - предоставляет класс посредника, который обрабатывает все коммуникации между различными классами.
	- Chain of Responsibility (Цепочка обязанностей) - озволяет избежать жесткой зависимости отправителя запроса от его получателя, при этом запрос может быть обработан несколькими объектами.
	- Observer (Наблюдатель) - позволяет одним обьектам следить и реагировать на события, происходящие в других объектах.
	- Strategy (Стратегия) - алгоритм стратегии может быть изменен во время выполнения программы.Command (Команда) - интерфейс команды объявляет метод для выполнения определенного действия.
	- State (Состояние) - объект может изменять свое поведение в зависимости от его состояния.
	- Visitor (Посетитель) - используется для упрощения операций над группировками связанных объектов.
	- Interpreter (Интерпретатор) - определяет грамматику простого языка для проблемной области.
	- Iterator (Итератор) - последовательно осуществляет доступ к элементам объекта коллекции, не зная его основного представления.
	- Memento (Хранитель) - используется для хранения состояния объекта, позже это состояние можно восстановить.
	
Singleton (Одиночка):
	class Singleton {
		private static Singleton instance = null;
		private Singleton() {}
		public static Singleton getInstance() {
			if (instance == null) {
				instance = new Singleton();
			}
			return instance;
		}
		public void setUp() {
			System.out.println("setUp");
		}
	}

	public class SingletonTest {//тест
		public static void main(String[] args){
			Singleton singelton = Singleton.getInstance();
			singelton.setUp();
		}
	}

-------------------------------------------------------------------------------------
	
Factory (Фабрика)
	class Factory {
		public OS getCurrentOS(String inputos) {
			OS os = null;
			if (inputos.equals("windows")) {
				os = new windowsOS();
			} else if (inputos.equals("linux")) {
				os = new linuxOS();
			} else if (inputos.equals("mac")) {
				os = new macOS();
			}
			return os;
			}
	}
	interface OS {
		void getOS();
	}
	class windowsOS implements OS {
		public void getOS () {
        System.out.println("применить для виндовс");
		}
	}
	class linuxOS implements OS {
		public void getOS () {
			System.out.println("применить для линукс");
		}
	}
	class macOS implements OS {
		public void getOS () {
			System.out.println("применить для мак");
		}
	}

	public class FactoryTest {//тест
		public static void main(String[] args){
			String win = "linux";
			Factory factory = new Factory();
			OS os = factory.getCurrentOS(win);
			os.getOS();
		}
	}
	
-------------------------------------------------------------------------------------
