<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
  <head>
    <meta content="text/html; charset=UTF-16LE"
      http-equiv="content-type">
    <title>ShildtResume</title>
  </head>
  <body>
    <h1 style="text-align: center;">Резюме по главам</h1>
    <h2>Глава 1</h2>
    Байт-код - это высокооптимизированный набор инструкций, выполнямых
    под управлением виртуальной машины Java. Использованиe байт-кода
    помогает улучшить характеристики переносимости и безопасности
    программ на Java.<br>
    <br>
    Ключевые принципы ООП: инкапсуляция, полиморфизм, наследование.<br>
    <br>
    Выполнение программы на Java начинается с выполнения метода <span
      style="font-style: italic;">main()</span>.<br>
    <br>
    Переменная - именованная область памяти. Содержимое переменной может
    изменяться в процессе выполнения программы.<br>
    <br>
    Общая форма оператора <span style="font-style: italic;">if</span>:<br>
    if (условие) оператор;<br>
    <br>
    Общая форма оператора <span style="font-style: italic;">for</span>:<br>
    for (инициализация; условие; итерация) оператор;<br>
    <br>
    Блок кода начинается с символа { и заканчивается символом }.<br>
    <br>
    В Java допускается произвольное форматирование исходного кода. Не
    имеет значения с какой позиции в строке начинается инструкция.<br>
    <br>
    <h2>Глава 2</h2>
    Диапазоны простых значений и области действия простых типов строго
    определены в Java для того, чтобы обеспечить переносимость программ
    с одной платформы на другую.<br>
    <br>
    Символьный тип задается ключевым словом <span style="font-style:
      italic;">char</span> . В Java для представления символов
    используется кодировка Unicode а не ASCII.<br>
    <br>
    Переменная boolean может принимать лишь два значения: true или
    false.<br>
    <br>
    Если оператор инкремента предшествует операнду, &nbsp;исполняющая
    система Java выполнит операцию до извлечения значения операнда и
    использования его в остальной части выражения. Если оператор
    инкремента следует после операнда, &nbsp;исполняющая система сначала
    извлечет значение, а потом инкременирует сам операнд.<br>
    <br>
    Каким образом укороченная логическая операция И может предотвратить
    деление на ноль:<br>
    if ((b !=0)&nbsp;&amp;&amp; (val / b)) ..<br>
    <br>
    Явное приведение типов требуется для преобразований между
    несовместимыми типами, а так же в случае преобразования, сужающего
    диапазон допустимых значений.<br>
    <br>
    Избыточные скобки не оказывают влияния на эффективность выполнения
    программы.<br>
    <br>
    Блок кода определяет область действия переменных.<br>
    <br>
    <h2>Глава 3</h2>
    <span style="font-family: Arial Rounded MT Bold;">Оператор break без
      метки вызывает немедленное завершение текущего цикла или выражения
      switch.</span> Оператор <span style="font-family: Arial Rounded
      MT Bold;">break с меткой передает управление в конец помеченного
      блока.<br>
      <br>
      Метка, используемая вместе с оператором break должна быть
      опеределена в блоке кода, содержащем этот оператор.<br>
      <br>
      <span style="font-weight: bold;">Объекты передаются в методы по
        ссылке.</span> Копии объектов никогда не создаются
      автоматически. Но <span style="font-weight: bold;">значения
        переменных-слылок копируются</span> при присваивании или вызове
      методов (подобно примитивам). &nbsp;Все изменения, который
      происходят с копией, никак не влияют на ее оригинал.<br>
      <br>
    </span><span style="font-family: Arial Rounded MT Bold;"></span>
    <h2>Глава 4</h2>
    Класс - это абстрактное логическое описание формы и поведения
    объекта. Объект - вещественный экземпляр класса.<br>
    <br>
    Класс определяется с помощью ключевого слова <span
      style="font-family: Arial;">class. </span>В операторе класс
    указываются код и данные, составляющие класс.<br>
    <br>
    Каждый объект класса содержит собственную копию переменных
    экземпляра этого класса.<br>
    <br>
    double MyMeth(int a, int b) {<br>
    &nbsp;&nbsp;&nbsp; //.. <br>
    &nbsp;&nbsp;&nbsp; return (double) ... ;<br>
    } - метод MyMeth принимает два параметра типа int и возвращает
    значение типа double<br>
    <br>
    Выполнение метода завершает оператор return. Он же передает значение
    вызывающей части программы.<br>
    <br>
    Имя конструктора должно совпадать с именем класса.<br>
    <br style="font-weight: bold;">
    <span style="font-weight: bold;"> Оператор new выделяет память для
      объекта и выполняет его инициализацию с помощью с конструктора</span>.<br>
    <br>
    Метод <span style="font-weight: bold;">finalize() </span>вызывается


    для объекта перед его непосредственным удалением из памяти.<br>
    <br>
    Ключевое слово<span style="font-weight: bold;"> this</span>
    обозначает ссылку на объект, для которого вызывается метод. Эта
    ссылка автоматически передается методу.<br>
    <br>
    Метод типа void не возвращает значение.<br>
    <br>
    <h2>Глава 5</h2>
    <p>Метод indexOf() находит первое вхождение указанной подстроки, а
      метод lastIndexOf() - последнее вхождение в текущей строке.<br>
    </p>
    <p>Начиная с версии JDK 7 инструкцией switch можно управлять с
      помощью объектов типа String.<br>
    </p>
    <h2>Глава 6</h2>
    <p>Модификатор доступа должен <i>предшествовать </i>объявлению
      члена класса.<br>
    </p>
    <p>Пример метода swap(), реализующего&nbsp; обмен содержимым межд
      двумя объектами:<br>
    </p>
    <p>void swap(Test ob1, Test ob2) {<br>
      &nbsp;&nbsp;&nbsp; int t;<br>
      &nbsp;&nbsp;&nbsp; <br>
      &nbsp;&nbsp;&nbsp; t = ob1.a;<br>
      &nbsp;&nbsp;&nbsp; ob1.a = ob2.a;<br>
      &nbsp;&nbsp;&nbsp; ob2.a = t;<br>
    </p>
    <p>&nbsp;&nbsp;&nbsp; }<br>
    </p>
    <p>Переменная, предназначенная для совместного использования, должна
      быть объявлена как <i>static</i>.<br>
    </p>
    <p>Статический блок служит для выполнения каких-либо инииализирующих
      действий в классе до создания конкретных объектов.<br>
    </p>
    <p>Внутренний класс - это нестатический вложенный класс.<br>
    </p>
    <p>Если требуется член класса, к которому могут обращаться только
      другие члены этого же класса, то его нужно объявить как <i>private</i>.<br>
    </p>
    <p><span style="font-weight: bold;">Имя метода и список его
        параметров вместе составляют </span><i style="font-weight:
        bold;">сигнатуру</i><span style="font-weight: bold;"> метода.</span><br>
    </p>
    <p>Если методу передается значение типа int, то в этом случае
      используется передача параметра по <i>значению</i>.<br>
    </p>
    <p>Методы с переменным числом аргументов перегружать <i>можно</i>.<br>
    </p>
    <h2>Глава 7</h2>
    <p>Суперкласс не имеет доступ к членам подкласса. Ему ничего не
      известно о существовании подклассов.<br>
    </p>
    <p>Подкласс может обращаться ко всем членам суперкласса, кроме тех,
      что объявлены как <b>private</b>.<br>
    </p>
    <p>Чтобы предотвратить доступ к членам суперкласса из подкласса, эти
      члены следует объявить как <b>final</b> (закрытые).<br>
    </p>
    <p>Ключевое слово <span style="font-weight: bold;">super</span>
      используется в двух случаях. Во-первых, с его помощью вызывается
      конструктор суперкласса (<i>super (список_параметров)</i>).
      Во-вторых, это ключевое слово обеспечивает доступ к членам
      суперкласса (<i>super.член_суперкласса</i>).<br>
    </p>
    <p>Конструкторы всегда вызываются в порядке наследования.<br>
    </p>
    <p>Когда переопределяемый метод вызывается по ссылке на суперкласс,
      его вариант определяется по типу объекта, на который делается
      ссылка.<br>
    </p>
    <p>Абстрактный класс это такой класс, который содержит хотя бы один
      абстрактный метод.<br>
    </p>
    <p>Для того, чтобы метод нельзя было переопределить, его нужно
      объявить как <b>final</b>. Чтобы предотвратить наследование от
      класса, его следует объявить как <b>final</b>.<br>
    </p>
    <p>Наследование, переопределеие методов и абстрактные классы
      поддерживают полиморфизм и позволяют создать обобщенную структуру,
      реализуемую различными классами. Так, абстрактный класс определяет
      согласованный интерфейс, общий для всех реализующих его классов
      (один интерфейс - множество методов).<br>
    </p>
    <p>Класс Object является суперклассом для всех остальных классов.<br>
    </p>
    <p>Для создания именованной константы следует использовать ключевое
      слово <b>final</b>.<br>
    </p>
    <br>
    <h2>Глава 8</h2>
    <p>Пространство имен - это область объявлений. Разделяя пространство
      имен на отдельные области, можно предотвратить конфликты имен.<br>
    </p>
    <p>Содердимое пакетов храниться в каталогах.<br>
    </p>
    <p>Для того, чтобы воспользоваться члеом пакета, нужно указать его
      полное имя или же импортировать этот член при помощи инструкции <span
        style="font-weight: bold;">import</span>.<br>
    </p>
    <p>Один интерфейс может быть реализован любым количеством классов.
      Класс может реализовать любое количество интерфейсов.<br>
    </p>
    <p>Один интерфейс может наследовать другой.<br>
    </p>
    <p>Переменные, объявленные в интерфейсе могут использоваться в
      качестве именованных констант, общих для всех файлов программы.
      Доступ к ним обеспечивается путем импорта того интерфейса, в
      котором они объявлены.<br>
    </p>
    <p>Пакет является контейнером для классов.<br>
    </p>
    <p>Пакет java.lang автоматически импортируется в любую программу на
      Java.<br>
    </p>
    <p>Начиная с JDK8 допускается определение статического метода
      интерфейса.<br>
    </p>
    <p>Начиная с JDK 9 интерфейс может включать закрытый метод.</p>
    <h2>Глава 9</h2>
    Класс <span style="font-family: Courier New,Courier,monospace;">Throwable</span>
    находится на вершине иерархии исключений.<br>
    <br>
    Если исключение не будет перехвачено, то произойдет аварийное
    завершение программы.<br>
    <br>
    Блок <span style="font-family: Courier New,Courier,monospace;">finally</span>
    выполнется по завершении работы блока <span style="font-family:
      Courier New,Courier,monospace;">try</span>.<br>
    <br>
    С помощью инструкции <span style="font-family: Courier
      New,Courier,monospace;">throws</span> объявлются все исключения,
    кроме <span style="font-family: Courier New,Courier,monospace;">RuntimeException</span>
    и <span style="font-family: Courier New,Courier,monospace;">Error</span>.<br>
    <br>
    С помощью инструкции <span style="font-family: Courier
      New,Courier,monospace;">throw</span> могут генерироваться лишь те
    исключения, которые унаследованы от класса <span
      style="font-family: Courier New,Courier,monospace;">Throwable</span>.<br>
    <br>
    Исключение может быть сгенерировано в результатше ошибки виртуальной
    машине Java, ошибки в программе или явным образом с помощью
    инструкции <span style="font-family: Courier
      New,Courier,monospace;">throw</span>.<br>
    <br>
    Классы <span style="font-family: Courier New,Courier,monospace;">Error</span>
    и <span style="font-family: Courier New,Courier,monospace;">Excpetion</span>
    производные от класса <span style="font-family: Courier
      New,Courier,monospace;">Throwable</span>.<br>
    <br>
    Групповой перехват исключений это такой перехват, которые позволяет
    два или более исключений одним блоком <span style="font-family:
      Courier New,Courier,monospace;">catch</span>.<br>
    <br>
    Исключения типа <span style="font-family: Courier
      New,Courier,monospace;">Error</span> не перехватываются.<br>
    <br>
    <h2>Глава 10</h2>
    Первоначально в Java были определены только байтовые потоки. Они
    удобны для ввода-вывода двоичных данных и поддерживают произвольный
    доступ к файлам. Символьные потоки отпимизированы для работы с
    кодировкой Unicod.<br>
    <br>
    Стандартные потоки ввода-вывода <span style="font-family: Courier
      New,Courier,monospace;">System.in</span>, <span
      style="font-family: Courier New,Courier,monospace;">System.out</span>,
    <span style="font-family: Courier New,Courier,monospace;">System.err</span>
    были определены в Java до появления символьных потоков.<br>
    <br>
    Один из способов открытия файла для чтения данных типа <span
      style="font-family: Courier New,Courier,monospace;">byte</span>:<br>
    &nbsp;&nbsp;&nbsp; <span style="font-family: Courier
      New,Courier,monospace;">FileInputStream fin = new
      FileInputStream("text");</span><br>
    <br>
    Один из способов открытия файла для чтения символов:<br>
    &nbsp;&nbsp;&nbsp; <span style="font-family: Courier
      New,Courier,monospace;">FileReader fr = new FileReader("text"); <br>
    </span><br>
    Один из способов открытия файла для выполнения операции ввода-вывода
    с произвольным доступом:<br>
    &nbsp;&nbsp;&nbsp; randfile = new RandomAccessFile("test". "rw");<br>
    <br>
    Для того, чтобы преобразовать числовую строку в ее двоичный
    эквивалент, следует воспользоваться одним из методов синтаксического
    разбора, определенных в классах оболочек типов, например Integer или
    Double.<br>
    <br>
    Поток System.in относится к типу InputStream.<br>
    <br>
    Метод read() класса InputStream по достижении конца потока
    возвращает значение -1.<br>
    <br>
    Поток типа DataInputStream используется для чтения двоичных данных.<br>
    <br>
    Классы Reader и Writer находятся на вершине иерархии классов
    символьного ввода-вывода.<br>
    <br>
    Инструкция try с ресурсами служит для &nbsp;автоматического
    управления ресурсами.<br>
    <br>
    Если для закрытия файла применяется традиционный способ, то лучше
    всего сделать это в блоке finally.<br>
    <br>
    <h2>Глава 11</h2>
    <p>Средства многопоточного программирования дают возможность
      использовать периоды простоя, возникающие практически в любой
      программе. Когда операции в одном потоке по каким то причинам
      приостановлены, выполняются другие потоки. В многоядерных системах
      два или более потока могут выполняться одновременно.<br>
    </p>
    <p>Для поддержки многопоточного программирования&nbsp; в Java
      предусмотрены класс Thread&nbsp; интерфейс Runnable.<br>
    </p>
    <p>Подклассы, производные от класса Thread, целесообразно создавать
      в тех случаях, когда требуется переопределить другие методы
      данного класса.<br>
    </p>
    <p>Ожидание завершения потокового объекта MyThrd: <br>
      &nbsp;&nbsp;&nbsp; MyThrd.join();<br>
    </p>
    <p>Установить приоритет потока на три уровня выше нормального: <br>
      &nbsp;&nbsp;&nbsp; MyThrd.setPriority(Thread.NORM_PRIORITY + 3);<br>
    </p>
    <p>Если указать ключевое слово synchronized в объявлении метода, то
      в каждый момент времени этот метод будет вызываться только в одном
      потоке для любого заданного объекта класса.<br>
    </p>
    <p>Методы wait() и notify() предназначены для обеспечения
      взаимодействия потоков.<br>
    </p>
    <p>Методы suspend(), resume() и stop() не рекомендуется применять,
      поскольку они могут стать причиной серьезных осложнений при
      выполнении программы.<br>
    </p>
    <p>Метод isAlive() возвращает значение true, если вызывающий поток
      выполняется, или значение false, если выполнение потока завершено.<br>
    </p>
    <h2>Глава 12</h2>
    <p>Самотипизированная константа - константаперечислимого типа,
      которая является объектом того перечисления, в которое она входит.<br>
    </p>
    <p>Все пересисления наследуют класс Enum.<br>
    </p>
    <p>Программа, для отображения списка констант и их значений:<br>
    </p>
    enum Tools {<br>
    &nbsp;&nbsp;&nbsp; SCREWDRIVER, WRENCH, HAMMER, PLIES<br>
    }<br>
    <br>
    class EnumTools {<br>
    &nbsp;&nbsp;&nbsp; public static void main(String[] args) {<br>
    &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; for(Tools d : Tools.values())
    {<br>
    &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;
    System.out.println(d + " имеет порядковое значение " + d.original()
    + '\n');<br>
    &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; }<br>
    &nbsp;&nbsp;&nbsp; }<br>
    }<br>
    <br>
    Автоупаковка - сохранение значения простого типа в объекте оболочки,
    а распаковка - извлечение значения из объекта оболочки.<br>
    <br>
    Статический импорт - размещение статических членов класса или
    интерфейса в глобальном пространстве имен. Это позволяет
    использовать статические члены без указания имени соответствующего
    класса или интерфейса.<br>
    <br>
    Статический импорт уместен только в отдельных случаях. Если
    доступным окажется слишком много статических членов, это может
    привести к конфликтам имен и нарушениюструктуры кода.<br>
    <br>
    Синтаксис аннотации основывается на интерфейсе.<br>
    <br>
    Маркерной называют аннотацию, не имеющую аргументов.<br>
    <br>
    Аннотировать можно любое объявление.<br>
    <span style="font-family: Courier New,Courier,monospace;"></span>
  </body>
</html>
